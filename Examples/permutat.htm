<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                                                        
         
  <meta http-equiv="content-type" content="text/html; charset=KOI8-R">
  <title>Подстановки в системе GAP</title>
                                                                        
          
  <meta name="description" content="Элементы теории колец">
                                               
  <meta name="author" content="А.Б.Коновалов">
</head>
  <body>
                                                                        
    
<div align="left">                 
<div align="left">                 
<div align="left">                 
<div align="left">                 <i><font face="Arial,Helvetica"><font
 size="-1"><a href="Examples.htm">Вернуться к списку примеров</a></font></font></i> 
                       
<hr width="100%" size="2">   </div>
                       </div>
                                           
<center></center>
                       </div>
                                                 
<div align="left"><b><small><font face="Helvetica, Arial, sans-serif"><br>
                </font></small></b>                
<div align="center"><font face="Times New Roman, Times, serif"><big><big><b><small>Подстановки 
   в системе GAP</small></b></big></big></font>   </div>
                </div>
                                    <br>
                     
<div align="justify">Перед тем, как приступить к рассказу о подстановках в
системе GAP, приведем необходимые теоретические сведения. Итак, пусть <i>M</i>={1,2,3,...,<i>n</i>}. 
   Взаимно однозначное отображение множества <i>M</i> первых <i>n</i> натуральных
   чисел на себя называется <b>подстановкой <i>n</i>-й степени</b>. Подстановку 
  <i>n</i>-й степени <i>s</i> можно записать в виде матрицы из двух строк 
и  <i>n</i> столбцов, в которой соответствующий элемент первой строки отображается 
  в находящийся под ним элемент второй строки (очевидно, что каждая строка 
 такой матрицы является перестановкой из <i>n</i> элементов). Если <i>x</i> 
 - элемент множества <i>M</i>, и <i>s</i> - подстановка, то образ элемента 
 <i>x</i> под действием подстановки <i>s</i> обозначается <i>s</i>(<i>x</i>). 
 Тогда умножение подстановок определяется как композиция отображений: <br>
         
<div align="center"><big>(<i>s</i>1*<i>s</i>2)(<i>x</i>) = <i>s</i>1(<i>s</i>2(<i>x</i>))</big>. 
  <br>
     </div>
     <br>
     Далее, подстановка <i>s</i> называется циклом длины <i>k</i>, если <i>s</i>(<i>a</i><sub>1</sub>)=<i>a</i><sub>2</sub>, 
   <i>s</i>(<i>a</i><sub>2</sub>)=<i>a</i><sub>3</sub>, ...  <i>s</i>(<i>a<sub>i</sub></i>)=<i>a<sub>i</sub></i><sub>+1</sub>
   и <i>s</i>(<i>a<sub>k</sub></i>)=<i>a</i><sub>1</sub> (разумеется, все
элементы,   входящие в один цикл, должны быть попарно различны). Для записи
циклов используется   более компактное обозначение: (<i>a</i><sub>1</sub>
<i>a</i><sub>2</sub>   <i>a</i><sub>3</sub> ... <i>a<sub>k</sub></i>). Циклы
называются независимыми,   если они не содержат общих элементов. Известно,
что каждую подстановку можно   разложить в произведение независимых циклов.
Например, подстановка (1,2,3)(4,5)   переводит 1 в 2, 2 в 3, 3 в 1, 4 в 5
и 5 - в 4. Цикл длины два называется   транспозицией. Каждая подстановка
разлагается в произведение конечного   числа транспозиций, количество которых
определяет четность подстановки.<br>
       <br>
       Подстановки являются стандартными объектами в системе GAP. При этом
 ввод   и вывод подстановок производится в виде произведения независимых
циклов.   Максимальным числом, которое может входить в запись подстановки,
является   2<sup>28</sup>-1. При попытке ввести подстановку, циклы которой
не являются   независимыми или не являются циклами вообще, выдается сообщение
об ошибке.   <br>
      <br>
      Примеры правильных и неправильных вариантов задания подстановок:<br>
       <br>
      <b><tt>gap&gt; a:=(1,2,3)(4,5);        # правильное задание подстановки<br>
      (1,2,3)(4,5)<br>
     gap&gt; a:=(1,2,3,1)(3,4,5);    # первый множитель - не цикл<br>
      Permutation: cycles must be disjoint and duplicate-free<br>
      gap&gt; a:=(1,2,3)(3,4,5);      # циклы не являются независимыми<br>
      Permutation: cycles must be disjoint and duplicate-free<br>
      gap&gt; b:=(1,2,3)*(3,4,5);     # так нужно поступать, если циклы не
 независимы<br>
      (1,2,4,5,3)                  # (в этом случае выполняется их умножение)<br>
     gap&gt; e:=();                  # так задается тождественная подстановка<br>
     ()</tt></b><br>
     <b><tt><br>
     </tt></b>Следует обратить внимание на то, что в GAP умножение подстановок 
  выполняется слева направо, а не справа налево, как было указано в приведенных 
  выше кратких теоретических сведениях. Это связано с тем, что для образа 
точки  <i>i</i> под действием подстановки <i>p</i> можно использовать как 
обозначение  <i>p</i>(<i>i</i>), так и обозначение <i>i<sup>p</sup></i>. В
GAP принят за основу второй вариант записи (поскольку запись <tt><b>p(i)</b></tt> 
интерпретировалась  бы как обращение к функции <b><tt>p</tt></b> с аргументом 
<tt><b>i</b></tt>),  и <i>i<sup>p</sup></i> записывается как <tt><b>i^p</b></tt>. 
Тогда выполняется  соотношение <tt><b>i^(p1*p2)=(i^p1)^p2</b></tt>, соответствующее 
правилу (<i>p</i><sub>1</sub>*<i>p</i><sub>2</sub>)(<i>i</i>) = <i>p</i><sub>1</sub>(<i>p</i><sub>2</sub>(<i>i</i>)).<br>
     <br>
     Если <tt><b>i^p</b></tt> не совпадает с <tt><b>i</b></tt>, то мы говорим,
   что <tt><b>i</b></tt> перемещается подстановкой <tt><b>p</b></tt>. В противном
   случае точка <tt><b>i</b></tt> называется неподвижной (или фиксированной)
   точкой относительно подстановки <tt><b>p</b></tt>. Прообраз точки <tt><b>i</b></tt> 
  относительно подстановки <tt><b>p</b></tt> записывается как <tt><b>i/p</b></tt>, 
  что позволяет быстро определить его без непосредственного вычисления подстановки, 
  обратной к <tt><b>p</b></tt>:<br>
       <br>
      <tt><b>gap&gt; 1^a;<br>
      2<br>
      gap&gt; 3^a;<br>
      1<br>
      gap&gt; 3/a; <br>
      2<br>
      gap&gt; 3/a=3^(a^-1); # проверим, что оба способа дают одинаковый результат<br>
      true</b></tt><br>
     <b><tt><br>
     </tt></b>Приведем еще несколько примеров действий над подстановками:<br>
     <b><tt><br>
     gap&gt; c:=(1,2,4)(7,3,6)(8,9); # зададим подстановку, состоящую из
трех   циклов<br>
      (1,2,4)(3,6,7)(8,9)<br>
      gap&gt; b*c;                    # и умножим ее на b             <br>
      (1,4,5,6,7,3,2)(8,9)<br>
      gap&gt; (1,2,3)^-1;             # так находят обратную подстановку<br>
        (1,3,2)<br>
       gap&gt; (1,2,3)^(1,2);          # а так - подстановку, сопряженную 
с  данной<br>
        (1,3,2)<br>
      gap&gt; (1,2,3)^(1,2)=(1,2)^1 * (1,2,3) * (1,2); # проверим это, вычислив 
  сопряженную подстановку<br>
      true<br>
      </tt><tt>gap&gt; b/c;                    # так можно быстро вычислить 
 </tt></b><b><tt>b*c^-1</tt></b><br>
      <b><tt> (3,4,5,7,6)(8,9)<br>
      gap&gt; b*c^-1;                 # проверим это, сравнив два последних 
 результата  <br>
      (3,4,5,7,6)(8,9)<br>
      </tt></b><br>
     Полезными также являются функция <tt><b>LeftQuotient(elm1,elm2)</b></tt>,
   возвращающая произведение <b><tt>elm1^(-1)*elm2</tt></b> (для подстановок
   она возвращает результат быстрее, чем непосредственное нахождение подстановки, 
  обратной к первой подстановки и последующее умножение результата на вторую 
  подстановку), а также функция <tt><b>Comm(elm1,elm2)</b></tt>, возвращающая 
  коммутатор <tt><b>elm1</b></tt> и <b><tt>elm2</tt></b>, который по определению 
  равен произведению <tt><b>elm1^(-1) * elm2^(-1) * elm1 * elm2</b></tt> 
:<br>
       <br>
      <b><tt> gap&gt; a:= (1,3)(4,6);; b:= (1,6,5,4,3,2);;<br>
     </tt></b><b><tt>  gap&gt; LeftQuotient( a, b );<br>
       (1,2)(3,6)(4,5)<br>
      </tt></b><b><tt>gap&gt; Comm( a, b );<br>
       (1,5,3)(2,6,4)<br>
     </tt></b><br>
     Как правило, для удобства в наименованиях функций GAP, предназначенных 
 для  работы с подстановками, слово <tt><b>Permutation </b></tt>сокращается 
 до <tt><b>Perm</b></tt>. Например, функция <tt><b>IsPerm </b></tt>проверяет, 
 является ли объект подстановкой:<br>
     <br>
     <tt><b>gap&gt; IsPerm( (1,3,4,6) ); <br>
     true<br>
     gap&gt; IsPerm( [1,3,4,6] ); <br>
     false<br>
     </b></tt><br>
     Подстановки в GAP не принадлежат к какой-либо специфической группе подстановок. 
  Это означает, что Вы можете работать с ними, не определяя группу подстановок, 
  которой они принадлежат. Подстановки считаются равными, если они перемещают 
  одно и то же множество точек, и образы соответствующих точек совпадают:<br>
     <br>
     <tt><b>gap&gt; (1,2,3)=(2,3,1);        <br>
     true<br>
     gap&gt; (1,2,3)(10)=(2,3,1)(11);<br>
     true<br>
     gap&gt; (1,2,3)=(1,3,2);        <br>
     false<br>
     </b></tt><br>
     Для перестановки элементов списка в соответствии с некоторой подстановкой 
  используется функция Permuted:<br>
     <br>
     <tt><b>gap&gt; Permuted( ["a","b","c","d"], (1,4)(2,3) ); <br>
     [ "d", "c", "b", "a" ]<br>
     </b></tt><br>
     Для изучения свойств множества точек, перемещаемых подстановкой или
набором   подстановок, используются функции <tt><b>SmallestMovedPoint</b></tt>,
  <b><tt>LargestMovedPoint</tt></b>,    <tt><b>MovedPoints </b></tt>и   <tt><b>NrMovedPoints</b></tt>. 
Аргументом  этих функций может быть одна подстановка, список подстановок, 
или, например,  группа подстановок или ее класс сопряженных элементов. Действие 
этих функций  описывается в следующей таблице.<br>
     <br>
         
<table cellpadding="2" cellspacing="2" border="1" width="100%">
       <tbody>
         <tr>
           <td valign="top"><br>
           </td>
           <td valign="top">Аргумент - подстановка<br>
           </td>
           <td valign="top">Аргумент - набор подстановок<br>
           </td>
         </tr>
         <tr>
           <td valign="top"><tt><b>SmallestMovedPoint</b></tt><br>
           </td>
           <td valign="top" align="justify">Возвращает наименьшее положительное 
  число, которое перемещается данной подстановкой, если такое число существует, 
  и <tt><b>infinity</b></tt>, если подстановка является тождественной<br>
           </td>
           <td valign="top">Возвращает наименьшее значение из всех  <tt><b>SmallestMovedPoint</b></tt> 
  для элементов из данного набора подстановок, и <tt><b>infinity</b></tt>, 
 если набор является пустым<br>
           </td>
         </tr>
         <tr>
           <td valign="top"><tt><b>LargestMovedPoint</b></tt><br>
           </td>
           <td valign="top">Возвращает наибольшее положительное число, которое 
  перемещается данной подстановкой, если такое число существует, и <tt><b>0</b></tt>, 
  если подстановка является тождественной<br>
           </td>
           <td valign="top">Возвращает наибольшее значение из всех  <tt><b>LargestMovedPoint 
        </b></tt>для элементов из данного набора подстановок, и <tt><b>0</b></tt>, 
  если набор является пустым<br>
           </td>
         </tr>
         <tr>
           <td valign="top"><tt><b>MovedPoints</b></tt><br>
           </td>
           <td valign="top">Возвращает множество положительных чисел, которые 
  перемещаются данной подстановкой.<br>
           </td>
           <td valign="top">Возвращает множество положительных чисел, которые 
  перемещаются хотя бы одной подстановкой из данного набора<br>
           </td>
         </tr>
         <tr>
           <td valign="top"><b><tt>NrMovedPoints</tt></b><br>
           </td>
           <td valign="top">Возвращает количество положительных чисел, которые 
  перемещаются данной подстановкой<br>
           </td>
           <td valign="top">Возвращает количество положительных чисел, которые 
  перемещаются хотя бы одной подстановкой из данного набора<br>
           </td>
         </tr>
                   
  </tbody>     
</table>
     <br>
     Пример:<br>
     <tt><b><br>
     gap&gt; SmallestMovedPointPerm((4,5,6)(7,2,8));<br>
       2<br>
       gap&gt; LargestMovedPointPerm((4,5,6)(7,2,8));<br>
       8<br>
       gap&gt; NrMovedPointsPerm((4,5,6)(7,2,8));<br>
       6<br>
       gap&gt; MovedPoints([(2,3,4),(7,6,3),(5,47)]);<br>
       [ 2, 3, 4, 5, 6, 7, 47 ]<br>
       gap&gt; NrMovedPoints([(2,3,4),(7,6,3),(5,47)]);<br>
       7<br>
       gap&gt; SmallestMovedPoint([(2,3,4),(7,6,3),(5,47)]);<br>
       2<br>
       gap&gt; LargestMovedPoint([(2,3,4),(7,6,3),(5,47)]);<br>
       47<br>
       gap&gt; LargestMovedPoint([()]);<br>
       0<br>
     gap&gt; SmallestMovedPoint(());<br>
     infinity</b></tt>  <br>
     <br>
       Функция <tt><b>SignPerm</b></tt> возвращает знак подстановки, который
  равен (-1)<i><sup>k</sup></i>, где <i>k</i> - количество циклов четной
длины   в разложении подстановки в произведение независимых циклов (цикл
четной длины  представляется в виде произведения нечетного числа транспозиций,
а нечетной  длины - в виде четного числа транспозиций). Таким образом, знак
подстановки  равен 1, если она четная, и -1, если она нечетная. Знак подстановки
является  гомоморфизмом из симметрической группы подстановой в мультипликативную
группу  { +1, -1 }, ядром которого является знакопеременная группа. <br>
     <br>
     <tt><b>  gap&gt; SignPerm((1,2,3)(4,5));<br>
       -1<br>
     </b></tt>  <br>
     Количество циклов каждой длины в разложении подстановки возвращает функция 
  <tt><b>CycleStructurePerm</b></tt>. Ее результатом является список, <i>i</i>-й 
  элемент которого содержит количество циклов длины <i>i</i>+1. Если подстановка 
  не содержит циклов длины <i>i</i>+1, то <i>i</i>-й элемент списка не определен. 
  Циклы длины 1 игнорируются. Например: <br>
       <br>
     <tt><b>gap&gt; CycleStructurePerm( (1,8)(2,4)(3,5,6));   <br>
     [ 2, 1 ]<br>
     gap&gt; CycleStructurePerm((1,2,3)(4,5,9,7,8));<br>
       [ , 1,, 1 ]<br>
     </b></tt><br>
     Кроме задания подстановок в виде произведения независимых циклов, существуют 
  различные способы конвертации подстановок в списки и наоборот. Функция <tt><b>ListPerm(perm)</b></tt>
  возвращает список, который содержит образы положительных чисел под действием
  подстановки <tt><b>perm</b></tt>, т.е. <tt><b>list[i] = i^perm</b></tt>,
 где <tt><b>i</b></tt> изменяется от <tt><b>1</b></tt> до <tt><b>LargestMovedPoint(perm)</b></tt>.
  Иными словами, для подстановки, заданной в виде произведения циклов, она
 возвращает нижнюю строку из ее представления в виде двустрочной матрицы.
<br>
     <br>
     Обратной к этой функции является <tt><b>PermList(list)</b></tt>, которая 
  возвращает подстановку, которая действует в соответствии со списком <tt><b>list</b></tt>. 
   Иными словами, <tt><b>i^perm = list[i]</b></tt>, если <tt><b>i</b></tt>
   находится в границах от <tt><b>1</b></tt> до длины списка <tt><b>list</b></tt>,
   и <tt><b>i^perm = i</b></tt>, если <tt><b>i</b></tt> больше его длины.
Эта  функция возвращает <tt><b>fail</b></tt>, если заданный список не определяет
  подстановку (например, не является плотным, содержит одинаковые числа,
содежит   целое число не из интервала  <tt><b>[ 1 .. Length( list ) ]</b></tt>
или  содержит элемент, который не является целым числом.<br>
       <br>
     Если <tt><b>src</b></tt> и <tt><b>dst</b></tt> - два списка положительных
  чисел одинаковой длины, и каждый из них не содержит одинаковых элементов,
  то функция <tt><b>MappingPermListList ( src, dst )</b></tt> возвращает
подстановку   <tt><b>perm</b></tt>, такую что <tt><b>src[i]^perm = dst[i]</b></tt>.
При   этом perm оставляет на месте все числа, превышающие максимальное из
чисел,   входящих в списки <tt><b>src</b></tt> и <tt><b>dst</b></tt>.<br>
       <br>
     Функция <tt><b>RestrictedPerm( perm, list )</b></tt> возвращает новую
 подстановку,  которая является ограничением подстановки <tt><b>perm</b></tt>
 на список <tt><b>list</b></tt>, т.е. действует на элементы списка <tt><b>list</b></tt>
 таким же образом, как и исходная подстановка <tt><b>perm</b></tt>, и фиксирует
 все точки, не входящие в список <tt><b>list</b></tt>. Список <tt><b>list</b></tt>
 должен быть замкнут относительно действия подстановки <tt><b>perm</b></tt>,
 т.е. вместе с каждым элементом <tt><b>i</b></tt> содержать его образ <tt><b>i^perm</b></tt>.<br>
     <br>
     Пример:<br>
     <br>
     <tt><b>  gap&gt; ListPerm((3,4,5));<br>
       [ 1, 2, 4, 5, 3 ]<br>
       gap&gt; PermList([1,2,4,5,3]);<br>
       (3,4,5)<br>
       gap&gt; MappingPermListList([2,5,1,6],[7,12,8,2]);<br>
       (1,8,5,12,11,10,9,6,2,7,4,3)<br>
       gap&gt; RestrictedPerm((1,2)(3,4),[3..5]);<br>
       (3,4)</b></tt></div>
   <br>
 
<div align="justify">   Группы, порожденные подстановками, задаются с помощью 
указания их порождающих  элементов. Зададим группу, порождаемую двумя подстановками: 
<br>
 </div>
 <br>
 <tt><b>gap&gt; s8 := Group( (1,2), (1,2,3,4,5,6,7,8) ); <br>
       Group( [ (1,2), (1,2,3,4,5,6,7,8) ] ) </b></tt><br>
 <br>
<div align="justify"> Как известно, это - симметрическая группа подстановок
8-й степени. Теперь    вычислим ее коммутант (который является знакопеременной
группой подстановок 8-й степени), найдем его порядок и установим, будет ли
он коммутативным:<br>
</div>
 <br>
 <tt><b>gap&gt; a8 := DerivedSubgroup( s8 );<br>
       Group([(1,2,3),(2,3,4),(2,4)(3,5),(2,6,4),(2,4)(5,7),<br>
              (2,8,6,4)(3,5)])<br>
       gap&gt; Size( a8 );  IsAbelian( a8 );<br>
       20160<br>
       false</b></tt><br>
   <br>
 Кроме этого, в системе имеются стандартные функции для задания симметрической 
и знакопеременной групп:<br>
 <br>
 <tt><b>   gap&gt; S3:=SymmetricGroup(3);<br>
   Sym( [ 1 .. 3 ] )<br>
   gap&gt; AsList(S3);           <br>
   [ (), (2,3), (1,2), (1,2,3), (1,3,2), (1,3) ]<br>
   gap&gt; A4:=AlternatingGroup(4);         <br>
   Alt( [ 1 .. 4 ] )<br>
   gap&gt; AsList(A4);             <br>
   [ (), (2,3,4), (2,4,3), (1,2)(3,4), (1,2,3), (1,2,4), (1,3,2), (1,3,4),
 <br>
     (1,3)(2,4), (1,4,2), (1,4,3), (1,4)(2,3) ]<br>
 </b></tt><br>
                           
<hr width="100%" size="2"><tt>          </tt></div>
    <big><tt>        <i><font face="Arial,Helvetica"><font size="-1"><big><a
 href="Examples.htm">Вернуться  к списку примеров</a></big></font></font></i>
       </tt></big>   
</body>
</html>
