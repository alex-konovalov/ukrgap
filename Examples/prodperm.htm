<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                                                        
                 
  <meta http-equiv="content-type" content="text/html; charset=KOI8-R">
  <title>Подстановки в системе GAP</title>
                                                                        
                        
  <meta name="description" content="Элементы теории колец">
                                                       
  <meta name="author" content="А.Б.Коновалов">
</head>
  <body>
                                                                        
        
<div align="left">                   
<div align="left">                   
<div align="left">                   
<div align="left">                 <i><font face="Arial,Helvetica"><font
 size="-1"><a href="Examples.htm">Вернуться к списку примеров</a></font></font></i> 
                          
<hr width="100%" size="2">   </div>
                         </div>
                                               
<center></center>
                         </div>
                                                     
<div align="left"><b><small><font face="Helvetica, Arial, sans-serif"><br>
                  </font></small></b>                  
<div align="center"><font face="Times New Roman, Times, serif"><big><big><b><small>Алгоритм 
умножения подстановок</small></b></big></big></font>   </div>
                  </div>
                                      <br>
                         
<div align="justify">Напомним, что взаимно однозначное отображение множества 
<i>M</i> первых <i>n</i> натуральных    чисел на себя называется <b>подстановкой 
<i>n</i>-й степени</b>. Если <i>x</i>   - элемент множества <i>M</i>, и <i>s</i> 
- подстановка, то образ элемента   <i>x</i> под действием подстановки <i>s</i> 
обозначается <i>s</i>(<i>x</i>).   Тогда умножение подстановок определяется 
как композиция отображений: <br>
             
<div align="center"><big>(<i>s</i>1*<i>s</i>2)(<i>x</i>) = <i>s</i>1(<i>s</i>2(<i>x</i>))</big>. 
   <br>
       </div>
       <br>
 Подстановки являются стандартными объектами в системе GAP. Они задаются
в виде произведения независимых циклов. При этом умножение подстановок  
 выполняется слева направо, а не справа налево. Это связано с тем, что для
образа  точки  <i>i</i> под действием подстановки <i>p</i> можно использовать
как  обозначение  <i>p</i>(<i>i</i>), так и обозначение <i>i<sup>p</sup></i>.
В GAP принят за основу второй вариант записи (поскольку запись <tt><b>p(i)</b></tt>
 интерпретировалась  бы как обращение к функции <b><tt>p</tt></b> с аргументом
 <tt><b>i</b></tt>),  и <i>i<sup>p</sup></i> записывается как <tt><b>i^p</b></tt>.
 Тогда выполняется  соотношение <tt><b>i^(p1*p2)=(i^p1)^p2</b></tt>, соответствующее
 правилу (<i>p</i><sub>1</sub>*<i>p</i><sub>2</sub>)(<i>i</i>) = <i>p</i><sub>1</sub>(<i>p</i><sub>2</sub>(<i>i</i>)).<br>
 <br>
 Для изучения алгоритма умножения подстановок справа налево приведем пример 
программы на языке GAP. Эта программа работает с подстановками, заданными 
в виде произведения независимых циклов в формате [[<i>a</i><sub>1</sub>,<i>a</i><sub>2</sub>,...,<i>a<sub>i</sub></i>],[<i>b</i><sub>1</sub>,<i>b</i><sub>2</sub>,...,<i>b<sub>j</sub></i>],...,[<i>z</i><sub>1</sub>,<i>z</i><sub>2</sub>,...,<i>z<sub>k</sub></i>]]. 
Мы вводим свою запись подстановок, отличную от принятой в GAP, специально 
для изучения правила умножения подстановок, и ни в коем случае не для практического 
применения в научных целях, так как в системе GAP уже имеется намного более 
эффективная возможность работы с подстановками. Данная программа также дает 
понятие о языке программирования GAP, так как содержит примеры его основных 
конструкций: условные переходы и три различных вида циклов - <b>for</b>, <b>while</b>
и <b>until</b>. <br>
 </div>
 <br>
 
<div align="justify">Сначала приведем текст программы без комментариев, а 
затем подробно ее разберем. Текст данной программы мог бы быть сокращен, однако
целью автора являлась разработка в учебных целях программы, алгоритм которой
максимально соответствовал бы последовательности шагов при умножении подстановок
вручную. Поэтому оптимизация программы предлагается в качестве упражнения.<br>
 </div>
 <tt><b><br>
 ProductOfTwoPermutations:=function( s1, s2 )<br>
 local c, i, p, points, pos, s, t, x;<br>
 s := Concatenation( s1, s2 );  <br>
 </b></tt><tt><b>if ForAny(s, x -&gt; Length( x ) &lt;&gt; Length( Set( x 
) ) ) then<br>
    Error("An argument do not represent a permutation !!!");<br>
  fi;</b></tt><br>
 <tt><b>t := [];<br>
 points := Set( Flat( s ) );<br>
 while Length(points) &gt; 0 do<br>
     c := [];  <br>
     p := Minimum( points );<br>
     Add( c, p );<br>
     repeat<br>
         for i in [ Length(s), Length(s)-1 .. 1 ] do<br>
             if p in s[i] then<br>
                 pos := Position( s[i], p );<br>
                 if pos = Length( s[i] ) then<br>
                     p := s[i][1];<br>
                 else<br>
                     p := s[i][pos+1];<br>
                 fi;<br>
             fi;<br>
         od;<br>
         if p &lt;&gt; c[1] then<br>
             Add( c, p );<br>
         fi;<br>
     until p = c[1];<br>
     Add( t, c );  <br>
     SubtractSet( points, c );<br>
 od;<br>
 return Filtered( t, x -&gt; Length( x ) &gt; 1 );<br>
 end;<br>
 <br>
 </b></tt>Введя данную функцию, мы можем воспользоваться ей следующим образом:<br>
 <br>
 <tt><b>gap&gt; ProductOfTwoPermutations([[2,3,5,4],[1,6]], [[1,3,5]]);<br>
 [ [ 1, 5, 6 ], [ 2, 3, 4 ] ]<br>
 </b></tt><br>
 Теперь более детально прокомментируем каждую строку программы:<br>
 <br>
 <tt><b>ProductOfTwoPermutations:=function( s1, s2 )<br>
 # Используемые переменные:<br>
 local t, # результирующий список независимых циклов<br>
       s, # объединенный список независимых циклов из разложений <br>
          # подстановок s1 и s2 (сначала перечисляются циклы из<br>
          # разложения подстановки s1, потом подстановки s2)<br>
  points, # множество точек, которые входят в запись s1 и s2<br>
       p, # текущая точка<br>
       i, # счетчик циклов в списке s<br>
     pos, # позиция текущей точки в текущем цикле s[i]<br>
       c, # текущий формируемый цикл, который после окончания<br>
          # его формирования добавляется к списку t<br>
       x; # служебная переменная (элемент списка при его переборе) <br>
 #<br>
 # Шаг 1. Соединяем первый и второй аргументы в один список <br>
 # (т.е. записываем вторую подстановку после первой)<br>
 s := Concatenation( s1, s2 );<br>
 #<br>
 # Проверяем, что каждый цикл не содержит повторяющихся элементов<br>
 # (в данной программе не проверяется, что циклы независимы)<br>
 if ForAny(s, x -&gt; Length( x ) &lt;&gt; Length( Set( x ) ) ) then<br>
   Error("An argument do not represent a permutation !!!");<br>
 fi;<br>
 #<br>
 # Шаг 2. Создаем пустой список, в который в процессе расчета <br>
 # будут добавляться списки, соответствующие независимым циклам <br>
 # из разложения итоговой подстановки <br>
 t := [];<br>
 #<br>
 # Шаг 3. Формируем множество точек, входящих в заданные подстановки<br>
 # (другие точки мы не рассматриваем). Оно будет нужно нам для <br>
 # выбора точек, которые еще не были нами рассмотрены, т.е. не входят<br>
 # в уже сформированные циклы результирующей подстановки t.<br>
 points := Set( Flat( s ) );<br>
 #<br>
 # Шаг 4. Последовательный выбор точки p из множества еще не входящих<br>
 # в запись s1*s2 точек. С выбранной точки p начинается формирование <br>
 # нового цикла (его запись можно начинать с любой точки, но для <br>
 # удобства мы выбираем в качестве р минимальную из таких точек). <br>
 while Length(points) &gt; 0 do<br>
   # Шаг 4.1. <br>
   # создаем пустой список c, в который будем записывать точки цикла<br>
   # (иными словами, открываем левую скобку)<br>
   c := [];<br>
   # Выбор минимального p, еще не входящего в запись s1*s2<br>
   p := Minimum( points );<br>
   # записываем р в список c - это первый элемент нашего цикла<br>
   Add( c, p );<br>
   # Шаг 4.2. Продолжение формирование цикла c: если на некотором шаге<br>
   # его последний элемент - точка p, то добавляем к циклу c образ <br>
   # точки p под действием подстановки s1*s2. Процесс продолжаем<br>
   # до тех пор, пока цикл не замкнется, т.е. пока не получим первый <br>
   # элемент цикла c.<br>
   repeat<br>
     # Шаг 4.3. Перебор циклов из списка s в обратном порядке<br>
     # для определения образа точки p<br>
     for i in [ Length(s), Length(s)-1 .. 1 ] do<br>
       # если текущий цикл s[i] не содержит p, мы его пропускаем<br>
       if p in s[i] then<br>
         # иначе определяем номер точки p в цикле s[i]<br>
         pos := Position( s[i], p );<br>
         if pos = Length( s[i] ) then<br>
           # если точка р - последняя в цикле s[i], то она<br>
           # переходит в первый его элемент<br>
           p := s[i][1];<br>
         else<br>
           # в противном случае она переходит в элемент цикла<br>
           # с номером, на единицу большим, т.е. следующий за ней<br>
           p := s[i][pos+1];<br>
         fi;<br>
       fi;<br>
       # если i не равняется единице, то возвращаемся на шаг 4.2, <br>
       # уменьшая i на единицу (т.к. перебираем циклы справа налево)<br>
     od; <br>
     # в результате после шага 4.3 вместо исходного значения р <br>
     # мы получили его образ под действием подстановки s1*s2. Если<br>
     # этот образ совпадает с первым элементом формируемого цикла,<br>
     # то цикл замкнулся (ставим правую скобку). В противном случае<br>
     # добавляем этот элемент к циклу и вовзращаемся на шаг 4.2<br>
     if p &lt;&gt; c[1] then<br>
       Add( c, p );    <br>
     fi;<br>
   until p = c[1];<br>
   # Добавляем полученный цикл к результирующему списку t<br>
   Add( t, c );    <br>
   # Теперь удаляем из списка points все точки, входящие в цикл c,<br>
   # для того, чтобы затем определить, какие еще точки не были учтены<br>
   SubtractSet( points, c );<br>
   # Если после этого список points еще не пуст, то возвращаемся <br>
   # на шаг 4 и начинаем формирование следующего цикла<br>
 od;<br>
 # если же перебрали уже все возможные точки, то удаляем из <br>
 # списка t циклы единичной длины, а затем возвращаем результат<br>
 return Filtered( t, x -&gt; Length( x ) &gt; 1 );<br>
 end;</b></tt> 
<div align="justify"><a href="prodperm.pdf"><img src="prodperm.gif"
 alt="Блок-схема" width="160" height="231" border="0" align="right"
 hspace="10" vspace="10">
 </a><br>
 Блок-схема данной программы находится <b><a href="prodperm.pdf">здесь</a></b>.<br>
 <br>
 Работу программы можно усовершенствовать, сделав ее более наглядной. Конечно, 
несложно было бы просто вставить в нее промежуточную печать результатов. Однако,
мы продемонстрируем другой подход, позволяющий управлять объемом информации,
выводимой на экран, без последующего внесения изменений в программу. Для
этого нужно ввести команду <br>
 </div>
 <br>
 <tt><b>DeclareInfoClass("MyInfo");<br>
 </b></tt><br>
 
<div align="justify">Эта команда определяет так называемый <b>InfoClass </b>под 
именем <b>"MyInfo"</b>. Ему соответствует уровень вывода информации, который 
называется  <b>InfoLevel</b>. По умолчанию <b>InfoLevel </b>для вновь созданного 
класса равен нулю, и никакие информационные сообщения не печатаются. Далее, 
для печати информационных сообщений в программу включаются строки вида<br>
 <tt><b><br>
 Info( MyInfo, i, "text", variable );</b></tt><br>
 <br>
 Если теперь ввести, например, команду <br>
 <br>
 <b><tt>SetInfoLevel(MyInfo,1);</tt></b><br>
 <br>
 то при этом все информационные сообщения, у которых параметр <i>i</i> не 
будет превышать 1, будут выдавать информацию на экран, а сообщения с большим 
значением параметра <i>i</i> будут игнорироваться. <br>
 <br>
 Приведенная выше программа с комментариями, в которой также добавлена печать 
информационных сообщений, находится <a href="prodperm.g"><b>здесь</b></a>. 
После чтения ее командой <br>
 <br>
 <tt><b>gap&gt; Read("prodperm.g");</b></tt><br>
 <br>
 для включения режима печати информационных сообщений нужно ввести команду</div>
 <br>
 <tt><b>gap&gt; SetInfoLevel(MyInfo,1);</b></tt><br>
 <br>
 Тогда работа с подстановками будет выглядеть так:<br>
 <br>
 <tt><b>gap&gt; ProductOfTwoPermutations([[2,3,5,4],[1,6]], [[1,3,5]]);<br>
   Starting from 1<br>
     ( 1<br>
       cycle 3 : 1 -&gt; 3<br>
       cycle 1 : 3 -&gt; 5<br>
     ( 1 5<br>
       cycle 3 : 5 -&gt; 1<br>
       cycle 2 : 1 -&gt; 6<br>
     ( 1 5 6<br>
       cycle 2 : 6 -&gt; 1<br>
     ( 1 5 6 )<br>
   Starting from 2<br>
     ( 1 5 6 )( 2<br>
       cycle 1 : 2 -&gt; 3<br>
     ( 1 5 6 )( 2 3<br>
       cycle 3 : 3 -&gt; 5<br>
       cycle 1 : 5 -&gt; 4<br>
     ( 1 5 6 )( 2 3 4<br>
       cycle 1 : 4 -&gt; 2<br>
     ( 1 5 6 )( 2 3 4 )<br>
 [ [ 1, 5, 6 ], [ 2, 3, 4 ] ]</b></tt><br>
 <br>
 
<div align="justify">Эти и<a href="prodperm.ppt"><img src="prodperm.jpg"
 alt="Диаграмма" width="336" height="252" border="0" align="left"
 hspace="20" vspace="10">
 </a>нформационные сообщения показывают следующую информацию: 
<ul>
  <li>с какой точки начинается запись текущего цикла;</li>
  <li>как выглядит уже записанный текст на текущем шаге алгоритма;</li>
  <li>как определяется элемент, который нужно записывать следующим (в т.ч.
какие циклы и каким образом участвуют в его определении). </li>
</ul>
Полезным упражнением будет изучение текста программы <tt><b><a
 href="prodperm.g">prodperm.g</a></b></tt> и сопоставление шаго алгоритма
и выводимых на печать информационных сообщений. </div>
 
<div align="justify"><br>
 Для изучения алгоритма умножения подстановок в виде произведения циклов
предлагаем ознакомиться также с презентацией в MS PowerPoint, показывающую
его на примере. Вы можете загрузить презентацию <b><a
 href="prodperm.ppt">здесь</a></b>. Если же у Вас не установлен MS PowerPoint,
то Вы можете загрузить изображение в формате WMF <a href="prodperm.wmf"><b>здесь</b></a>.<br>
 <br>
 В заключение отметим, что при сверке студентами результатов расчетов с ответами
 в учебнике следует быть внимательным, так как в некоторых изданиях принято 
умножать подстановки слева направо. В этом случае для совпадения ответа их 
порядок должен быть изменен на противоположный.<br>
 </div>
                               
<hr width="100%" size="2"><tt>          </tt></div>
      <big><tt>        <i><font face="Arial,Helvetica"><font size="-1"><big><a
 href="Examples.htm">Вернуться  к списку примеров</a></big></font></font></i>
        </tt></big>    
</body>
</html>
