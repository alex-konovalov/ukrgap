DeclareInfoClass("MyInfo");
# InfoClass "MyInfo" определяется для управления объемом
# информации, выводимой на экран в процессе работы программы.
# По умолчанию InfoLevel данного класса равен нулю, и при
# обращении к функции только возвращается результат, например:
#
# gap> ProductOfTwoPermutations([[2,3,5,4],[1,6]], [[1,3,5]]);
# [ [ 1, 5, 6 ], [ 2, 3, 4 ] ]
#
# Если теперь ввести команду 
# SetInfoLevel(MyInfo,1);
# то в процессе вычислений печатаются еще и информационные 
# сообщения, определенные в программе, например:
#
# gap> ProductOfTwoPermutations([[2,3,5,4],[1,6]], [[1,3,5]]);
#   Starting from 1
#     ( 1
#       cycle 3 : 1 -> 3
#       cycle 1 : 3 -> 5
#     ( 1 5
#       cycle 3 : 5 -> 1
#       cycle 2 : 1 -> 6
#     ( 1 5 6
#       cycle 2 : 6 -> 1
#     ( 1 5 6 )
#   Starting from 2
#     ( 1 5 6 )( 2
#       cycle 1 : 2 -> 3
#     ( 1 5 6 )( 2 3
#       cycle 3 : 3 -> 5
#       cycle 1 : 5 -> 4
#     ( 1 5 6 )( 2 3 4
#        cycle 1 : 4 -> 2
#     ( 1 5 6 )( 2 3 4 )
# [ [ 1, 5, 6 ], [ 2, 3, 4 ] ]


ProductOfTwoPermutations:=function( s1, s2 )
#
# Пусть s1 и s2 - две подстановки, заданные в виде произведения
# независимых циклов, и представленные в виде списка списков, т.е.
# в виде [ [a1,a2,...,ai], [b1,b2,...,bj], ... , [z1,z2,...,zk] ].
# Данная функция вычисляет их произведение, определенное по 
# правилу (s1*s2)(x) = s1(s2(x)), т.е. сначала на точку х 
# действует подстановка s2, а потом - s1. 
# В результате возвращается подстановка s1*s2, представленная 
# списком списков аналогичного вида.
#
# Собственно алгорим произведения подстановок реализован следующим
# образом (остальная часть программы - это в основном организация
# вывода на экран и проверка корректности ввода аргументов):
#
# ProductOfTwoPermutations:=function( s1, s2 )
# t := [];
# s := Concatenation( s1, s2 );
# points := Set( Flat( s ) );
# while Length(points) > 0 do
#   c := [];
#   p := Minimum( points );
#   Add( c, p );
#   repeat
#     for i in [ Length(s), Length(s)-1 .. 1 ] do
#       if p in s[i] then
#         pos := Position( s[i], p );
#         if pos = Length( s[i] ) then
#           p := s[i][1];
#         else
#           p := s[i][pos+1];
#         fi;
#       fi;
#     od; 
#     if p <> c[1] then
#       Add( c, p );    
#     fi;
#   until p = c[1];
#   Add( t, c );    
#   SubtractSet( points, c );
# od;
# return Filtered( t, x -> Length( x ) > 1 );
# end;
#
# В системе GAP уже имеется возможность работы с подстановками, 
# и данный пример предназначен только лишь для изучения правила
# умножения подстановок, но ни в коем случае не для практического 
# применения в научных целях. При этом следует также помнить, что
# в системе GAP умножение подстановок производится справа налево. 
# Это объясняется тем, что в GAP образ точки x под действием 
# подстановки s определяется командой x^s, и тогда записи
# x^(s1*s2) = (x^s1)^s2  и  (s1*s2)(x) = s1(s2(x)) эквивалентны.
#
# При сверке студентами результатов расчетов с ответами в 
# учебнике также следует быть внимательным, так как в некоторых 
# изданиях принято умножать подстановки слева направо. В этом
# случае для совпадения ответа их порядок должен быть изменен на 
# противоположный.
# 
# Текст данной программы мог бы быть сокращен, однако целью автора
# являлась разработка программы, алгоритм которой максимально 
# соответствовал бы последовательности шагов при умножении
# подстановок вручную. Поэтому оптимизация программы предлагается
# студентам в качестве упражнения.
#                                       Коновалов А.Б, ноябрь 2004
# Используемые переменные:
local t, # результирующий список независимых циклов
      s, # объединенный список независимых циклов из разложений 
         # подстановок s1 и s2 (сначала перечисляются циклы из
         # разложения подстановки s1, потом подстановки s2)
 points, # множество точек, которые входят в запись s1 и s2
      p, # текущая точка
      i, # счетчик циклов в списке s
    pos, # позиция текущей точки в текущем цикле s[i]
      c, # текущий формируемый цикл, который после окончания
         # его формирования добавляется к списку t
      x, # служебная переменная (элемент списка при его переборе) 
    txt; # символьная переменная для хранения записи подстановки
#
# Шаг 1. Соединяем первый и второй аргументы в один список 
# (т.е. записываем вторую подстановку после первой)
s := Concatenation( s1, s2 );
#
# Проверяем, что каждый цикл не содержит повторяющихся элементов
# (в данной программе не проверяется, что циклы независимы)
if ForAny(s, x -> Length( x ) <> Length( Set( x ) ) ) then
  Error("An argument do not represent a permutation !!!");
fi;
#
# Шаг 2. Создаем пустой список, в который в процессе расчета 
# будут добавляться списки, соответствующие независимым циклам 
# из разложения итоговой подстановки 
t := [];
#
# инициализируем символьную переменную для хранения записи s1*s2
txt:=""; 
#
# Шаг 3. Формируем множество точек, входящих в заданные подстановки
# (другие точки мы не рассматриваем). Оно будет нужно нам для 
# выбора точек, которые еще не были нами рассмотрены, т.е. не входят
# в уже сформированные циклы результирующей подстановки t.
points := Set( Flat( s ) );
#
# Шаг 4. Последовательный выбор точки p из множества еще не входящих
# в запись s1*s2 точек. С выбранной точки p начинается формирование 
# нового цикла (его запись можно начинать с любой точки, но для 
# удобства мы выбираем в качестве р минимальную из таких точек). 
while Length(points) > 0 do
  # Шаг 4.1. 
  # создаем пустой список c, в который будем записывать точки цикла
  # (иными словами, открываем левую скобку)
  c := [];
  txt := Concatenation( txt, "( " );
  # Выбор минимального p, еще не входящего в запись s1*s2
  p := Minimum( points );
  # записываем р в список c - это первый элемент нашего цикла
  Add( c, p );
  Info( MyInfo, 1, "Starting from ", p );
  txt := Concatenation( txt, String(p) );
  Info( MyInfo, 1, "  ", txt );
  # Шаг 4.2. Продолжение формирование цикла c: если на некотором шаге
  # его последний элемент - точка p, то добавляем к циклу c образ 
  # точки p под действием подстановки s1*s2. Процесс продолжаем
  # до тех пор, пока цикл не замкнется, т.е. пока не получим первый 
  # элемент цикла c.
  repeat
    # Шаг 4.3. Перебор циклов из списка s в обратном порядке
    # для определения образа точки p
    for i in [ Length(s), Length(s)-1 .. 1 ] do
      # если текущий цикл s[i] не содержит p, мы его пропускаем
      if p in s[i] then
        # иначе определяем номер точки p в цикле s[i]
        pos := Position( s[i], p );
        if pos = Length( s[i] ) then
          # если точка р - последняя в цикле s[i], то она
          # переходит в первый его элемент
          Info( MyInfo, 1, "    cycle ", i, " : ", p, " -> ", s[i][1]);
          p := s[i][1];
        else
          # в противном случае она переходит в элемент цикла
          # с номером, на единицу большим, т.е. следующий за ней
          Info( MyInfo, 1, "    cycle ", i, " : ", p, " -> ", s[i][pos+1]);
          p := s[i][pos+1];
        fi;
      fi;
      # если i не равняется единице, то возвращаемся на шаг 4.2, 
      # уменьшая i на единицу (т.к. перебираем циклы справа налево)
    od; 
    # в результате после шага 4.3 вместо исходного значения р 
    # мы получили его образ под действием подстановки s1*s2. Если
    # этот образ совпадает с первым элементом формируемого цикла,
    # то цикл замкнулся (ставим правую скобку). В противном случае
    # добавляем этот элемент к циклу и вовзращаемся на шаг 4.2
    if p <> c[1] then
      Add( c, p );    
      txt := Concatenation( txt, " ", String(p) );
      Info( MyInfo, 1, "  ", txt );
    fi;
  until p = c[1];
  txt := Concatenation( txt, " )" );
  Info( MyInfo, 1, "  ", txt );
  # Добавляем полученный цикл к результирующему списку t
  Add( t, c );    
  # Теперь удаляем из списка points все точки, входящие в цикл c,
  # для того, чтобы затем определить, какие еще точки не были учтены
  SubtractSet( points, c );
  # Если после этого список points еще не пуст, то возвращаемся 
  # на шаг 4 и начинаем формирование следующего цикла
od;
# если же перебрали уже все возможные точки, то удаляем из 
# списка t циклы единичной длины, а затем возвращаем результат
return Filtered( t, x -> Length( x ) > 1 );
end;